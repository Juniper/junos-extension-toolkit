/* 
 * This file defines the ACL package for JUNOS. 
 *
 * Brief Description of the key concepts associated with this package and functionality is
 * as follows:
 *
 * ACL is an acronym to Access List which is a basic stateless forwarding construct to match 
 * on packet content and take a set of actions if packet passes the matching criteria.
 *
 * An ACL is made up of a ordered set of ACL Entries, which defines how a packet is matched
 * against configured criteria and be treated.
 *
 * Each ACL Entry or ACE defines a set of packet matching criteria and a set of action to take 
 * on the packet if the matching criteria is true. A packets needs to match ALL the matches in 
 * an ACE to be considered a match.
 *
 * A Match is defined by an operation, packet field and value to be matched against. For details
 * on the operations supported and various packet fields that could be matched, refer the 
 * corresponding Enum/Message structure below.
 * 
 * An action determines what to do with the packet on meeting the matching criteria. There are two
 * types of actions, viz. terminating and non-terminating. Each ACE can have zero or more  
 * non-terminating actions and zero or exactly one terminating action. A non-terminating action is 
 * one that does not stop the packet to undergo the rest of the ACL processing. An terminating action 
 * is one, that stops the packet to undergo any further ACL processing. 
 *
 * An attachment point or a bind point is the point in path of packet processing where the packet is
 * subjected to ACL processing. An attachment point is defined by attachment entity and direction in 
 * which the ACL is applied. For eg. a typical bind point is an interface where a packet is subjected 
 * to ACL.
 *
 * Diagram below depicts an object diagram for a typical ACL.
 * Legends:
 *           ACE-1 is the ordered Access List Entry at position 1.
 *           ACE-n is the ordered Access List Entry at position n.
 *             M-n is the match number n in list of matching criteria in a given ACE.
 *             A-n is the action number n in the list of actions for a given ACE.
 *                    No no more than 1 action could be a terminating action.
 *    
 *        +-------+-------+-----+------+ 
 * ACL -> | ACE-1 | ACE-2 | ... | ACE-n|
 *        +-------+-------+-----+------+ 
 *            | 
 *            | 
 *            |      +-----+
 *            +----->| M-1 |
 *                   +-----+
 *                   | M-2 |
 *                   +-----+
 *                   | ... |
 *                   +-----+
 *                   | M-n |
 *                   +-----+
 *                      |
 *                      |           +-----+
 *                      +---------->| A-1 |
 *                                  +-----+
 *                                  | A-2 |
 *                                  +-----+
 *                                  | ... |
 *                                  +-----+
 *                                  | A-n |
 *                                  +-----+
 *
 */


syntax = "proto3";
import "jnx_addr.proto";

package acl;

/*
 *  Boolean types 
 */

enum AclBooleanType {

    ACL_FALSE = 0;
    ACL_TRUE = 1;
}

/*
 *  Supported Match Operations
 */

enum AclMatchOperation {

    ACL_MATCH_OP_INVALID = 0;
    ACL_MATCH_OP_EQUAL = 1;
    ACL_MATCH_OP_NOT_EQUAL = 2;
}

/*
 *  Various ACL Policer Type
 */

enum AclPolicerType {

    // Invalid policer type
    ACL_POLICER_INVALID = 0;

    // Single rate two color
    ACL_TWO_COLOR_POLICER = 1;

    // Singel rate three color
    ACL_SINGLE_RATE_THREE_COLOR_POLICER = 2;

    // Two rate three color
    ACL_TWO_RATE_THREE_COLOR_POLICER = 3;

    // Hierarchical 
    ACL_HIERARCHICAL_POLICER = 4;
}

/*
 * Policer Flags
 */

enum AclPolicerFlags {

    ACL_POLICER_FLAG_INVALID = 0;
 
    // The policer instance is activated for each ACE its referenced.
    ACL_POLICER_FLAG_TERM_SPECIFIC = 1; 

    // The policer instance is activated at global ACL level.
    ACL_POLICER_FLAG_FILTER_SPECIFIC = 2;
}

/*
 * Policer Rate unit
 */

enum AclPolicerRate {

    ACL_POLICER_RATE_INVALID = 0;

    // Bits per second
    ACL_POLICER_RATE_BPS = 1;
       
    // Kilobits per second
    ACL_POLICER_RATE_KBPS = 2;

    // Megabits per second
    ACL_POLICER_RATE_MBPS = 3;

    // Gigabits per second
    ACL_POLICER_RATE_GBPS = 4;
}

/*
 * Policer Burst Size
 */

enum AclPolicerBurstSize {
   
    ACL_POLICER_BURST_SIZE_INVALID = 0;

    // Bytes
    ACL_POLICER_BURST_SIZE_BYTE = 1;

    // KiloBytes
    ACL_POLICER_BURST_SIZE_KBYTE = 2;

    // MegaBytes
    ACL_POLICER_BURST_SIZE_MBYTE = 3;

    // GigaBytes
    ACL_POLICER_BURST_SIZE_GBYTE = 4;
}

/*
 * Color mode for SRTCM and TRTCM
 */

enum AclColorModeType {

    ACL_COLOR_MODE_INVALID = 0;

    //Color Blind
    ACL_COLOR_MODE_COLOR_BLIND = 1;

    //Color Aware
    ACL_COLOR_MODE_COLOR_AWARE = 2;
}

/*
 * Loss Priority
 */

enum AclLossPriority {

    ACL_LOSS_PRIORITY_INVALID = 0;

    ACL_LOSS_PRIORITY_HIGH = 1;

    ACL_LOSS_PRIORITY_MEDIUM_HIGH = 2;

    ACL_LOSS_PRIORITY_MEDIUM_LOW = 3;

    ACL_LOSS_PRIORITY_LOW = 4;
}

/*
 * Forwarding Class
 */

enum AclForwardingClass {

    ACL_FORWARDING_CLASS_INVALID = 0;

    ACL_FORWARDING_CLASS_ASSURED = 1;

    ACL_FORWARDING_CLASS_BEST_EFFORT = 2;

    ACL_FORWARDING_CLASS_EXPEDITED = 3;

    ACL_FORWARDING_CLASS_NETWORK_CONTROL = 4;
}

/*
 * STP match Flags
 */

enum AclStpMatchFlags {

    ACL_MATCH_STP_FLAG_INVALID = 0;

    ACL_MATCH_STP_FLAG_BLOCKING = 1;

    ACL_MATCH_STP_FLAG_FORWARDING = 2;
}

/*
 * Various Reject Action Reasons.
 */

enum AclEntryActionRejectReason {

    // Send ICMP Administratively Prohibited message
    ACL_ACTION_REJECT_ADMINISTRATIVELY_PROHIBITED = 0;

    // Send ICMP Bad Host ToS message 
    ACL_ACTION_REJECT_BAD_HOST_TOS = 1;

    // Send ICMP Bad Network ToS message 
    ACL_ACTION_REJECT_BAD_NETWORK_TOS = 2;

    // Send ICMP Fragmentation Needed message 
    ACL_ACTION_REJECT_FRAGMENTATION_NEEDED = 3;

    // Send ICMP Host Prohibited message 
    ACL_ACTION_REJECT_HOST_PROHIBITED = 4;

    // Send ICMP Host Unknown message
    ACL_ACTION_REJECT_HOST_UNKNOWN = 5;

    // Send ICMP Host Unreachable message 
    ACL_ACTION_REJECT_HOST_UNREACHABLE = 6;

    // Send ICMP Network Prohibited message 
    ACL_ACTION_REJECT_NETWORK_PROHIBITED = 7;

    // Send ICMP Network Unknown message 
    ACL_ACTION_REJECT_NETWORK_UNKNOWN = 8;

    // Send ICMP Network Unreachable message 
    ACL_ACTION_REJECT_NETWORK_UNREACHABLE = 9;

    // Send ICMP Port Unreachable message 
    ACL_ACTION_REJECT_PORT_UNREACHABLE = 10;

    // Send ICMP Precedence Cutoff message 
    ACL_ACTION_REJECT_PRECEDENCE_CUTOFF = 11;

    // Send ICMP Precedence Violation message 
    ACL_ACTION_REJECT_PRECEDENCE_VIOLATION = 12;

    // Send ICMP Protocol Unreachable message 
    ACL_ACTION_REJECT_PROTOCOL_UNREACHABLE = 13;

    // Send ICMP Source Host Isolated message 
    ACL_ACTION_REJECT_SOURCE_HOST_ISOLATED = 14;

    // Send ICMP Source Route Failed message 
    ACL_ACTION_REJECT_SOURCE_ROUTE_FAILED = 15;

    // Send TCP Reset message 
    ACL_ACTION_REJECT_TCP_RESET = 16;
}

/* A void message */
message AccessListVoid {
    string void = 1;
}

/* 
 * Policer parameter for two color policer
 */

message AclPolicerTwoColor {

    // Bandwidth unit 
    AclPolicerRate bw_unit = 1;

    // Bandwidth rate 
    uint64 bandwidth = 2;

    // Burst unit 
    AclPolicerBurstSize burst_unit = 3;

    // Burst size 
    uint64 burst_size = 4;

    // Loss priority 
    AclLossPriority lp = 5;

    // Forwarding class. 
    string fc_string =  6;

    // Discard action 
    AclBooleanType discard = 7;
}

/* 
 * Policer parameter for single rate three color policer
 */
 
message AclPolicerSingleRateThreeColor {
   
    // Bandwidth unit 
    AclPolicerRate committed_rate_unit = 1;

    // Bandwidth rate 
    uint64 committed_rate = 2;

    // Burst unit 
    AclPolicerBurstSize committed_burst_unit = 3;

    // Burst size 
    uint64 committed_burst_size = 4;

    // Burst size 
    uint64 excess_burst_size = 5;

    // Burst unit 
    AclPolicerBurstSize excess_burst_unit = 6;

    // Discard action 
    AclBooleanType discard = 7;

    //Color mode
    AclColorModeType color_mode = 8;
}

/* 
 * Policer parameter for two rate three color policer
 */
 
message AclPolicerTwoRateThreeColor {

    // Bandwidth unit 
    AclPolicerRate committed_rate_unit = 1;

    // Bandwidth rate 
    uint64 committed_rate = 2;

    // Burst unit 
    AclPolicerBurstSize committed_burst_unit = 3;

    // Burst size 
    uint64 committed_burst_size = 4;

    // Bandwidth unit 
    AclPolicerRate excess_rate_unit = 5;

    // Bandwidth rate 
    uint64 excess_rate = 6;

    // Burst unit 
    AclPolicerBurstSize excess_burst_unit = 7;

    // Burst size 
    uint64 excess_burst_size = 8;

    // Discard action 
    AclBooleanType discard = 9;

    //Color mode
    AclColorModeType color_mode = 10;
}

/*
 * Heirarchical Policer parameters
 */

message AclPolicerHierarchical {

    // Bandwidth unit 
    AclPolicerRate aggregate_rate_unit = 1;

    // Bandwidth rate 
    uint64 aggregate_rate = 2;

    // Burst unit 
    AclPolicerBurstSize aggregate_burst_size_unit = 3;

    // Burst size 
    uint64 aggregate_burst_size = 4;

    // Bandwidth unit 
    AclPolicerRate premium_rate_unit = 5;

    // Bandwidth rate 
    uint64 premium_rate = 6;

    // Burst unit 
    AclPolicerBurstSize premium_burst_size_unit = 7;

    // Burst size 
    uint64 premium_burst_size = 8;

    // Discard action 
    AclBooleanType discard = 9;
}

/* 
 * Policer Parameter
 */

message AclPolicerParameter {
    oneof OneOf_PolicerParameter {

        // Two color 
        AclPolicerTwoColor two_color_parameter = 1;

        // Three color 
        AclPolicerSingleRateThreeColor sr_three_color_parameter = 2;

        // Three color 
        AclPolicerTwoRateThreeColor tr_three_color_parameter = 3;

        // Hierarchcical 
        AclPolicerHierarchical hierarchical_parameter = 4;
    }
}

/* 
 * ACL Policer
 */

message AccessListPolicer {

    // Policer name 
    string policer_name = 1;

    // Policer type 
    AclPolicerType policer_type = 2;

    // Policer Flags 
    AclPolicerFlags policer_flag = 3;

    // Policer Paremeter 
    AclPolicerParameter policer_params = 4;
}

/* 
 * Destination Address match condition
 */

message AclMatchIpAddress {

    // address
    jnxBase.IpAddress addr = 1; 

    // Destination prefix length 
    uint32 prefix_len = 2;

    // AclMatch op 
    AclMatchOperation match_op = 3;
}

/* 
 * Port match condition
 */

message AclMatchPort {

    // Minimum port 
    int32 min = 1;

    // Maximum port 
    int32 max = 2;

    // AclMatch op 
    AclMatchOperation match_op = 3;
}

/* 
 * Ip Precedence match
 */

message AclMatchIpPrecedence {

    // Minimum precedence
    Precedence min = 1;

    // Maximum precedence
    Precedence  max = 2;

    // AclMatch op
    AclMatchOperation match_op = 3;

}

/* 
 * Traffic class match
 */

message AclMatchTrafficClass {

    // Minimum value
    int32 min = 1;

    // Maximum value
    int32 max = 2;

    // AclMatch op
    AclMatchOperation match_op = 3;
}

/* 
 * DSCP (diffserv code point) match condition
 */

message AclMatchDscpCode {

    // Minimum Dscp code 
    uint32 min = 1;

    // Maximum Dscp code 
    uint32 max = 2;

    // AclMatch op 
    AclMatchOperation match_op = 3;

}

/* 
 * IP Protocol match condition
 */
 
message AclMatchProtocol {

    // Minimum Protocol number 
    uint32 min = 1;

    // Maximum Protocol number 
    uint32 max = 2;

    // AclMatch op 
    AclMatchOperation match_op = 3;
}

/* 
 * ICMP type match condition
 */
 
message AclMatchIcmpType {

    // Minimum Icmp type 
    uint32 min = 1;

    // Maximum Icmp type 
    uint32 max = 2;

    // AclMatch op 
    AclMatchOperation match_op = 3;
}

/* 
 * ICMP code match condition
 */
 
message AclMatchIcmpCode {

    // Minimum Icmp code 
    uint32 min = 1;

    // Maximum Icmp code 
    uint32 max = 2;

    // AclMatch op 
    AclMatchOperation match_op = 3;
}

/*  
 * Packet length match condition
 */
 
message AclMatchPktLen {

    // Minimum Packet length 
    uint32 min = 1;

    // Maximum Packet length 
    uint32 max = 2;

    // AclMatch op 
    AclMatchOperation match_op = 3;
}

/*  
 * Loss Priority match condition
 */
message AclMatchLossPriority {
    // Loss Priority match 
    AclLossPriority lp = 1;

    // AclMatch op 
    AclMatchOperation match_op = 2;
}

/*  
 * Forwarding class match condition
 */ 
message AclMatchForwardingClass {
    // Loss Priority match 
    AclForwardingClass fwd_class = 1;

    // AclMatch op 
    AclMatchOperation match_op = 2;
}

/*  
 * NextHeader match condition
 */

message AclMatchNextHeader {

    // Minimum Label value 
    uint32 min = 1;

    // Maximum Label Value 
    uint32 max = 2;

    // AclMatch op 
    AclMatchOperation match_op = 3;
}

/*  
 * Mpls label match condition
 */

message AclMatchMplsLabel {

    // Minimum Label value 
    uint32 min = 1;

    // Maximum Label Value 
    uint32 max = 2;

    // AclMatch op 
    AclMatchOperation match_op = 3;
}

/*  
 * VlanId match condition
 */

message AclMatchVlanId {

    // Minimum Label value 
    uint32 min = 1;

    // Maximum Label Value 
    uint32 max = 2;

    // AclMatch op 
    AclMatchOperation match_op = 3;
}

/*  
 * Mesh Group match condition
 */

message AclMatchMeshGroup {

    //  mesh_group_id value 
    uint32 mesh_group_id = 1;

    // AclMatch op 
    AclMatchOperation match_op = 2;
}

/*  
 * L2 token match condition
 */

message AclMatchL2Token {

    //  L2 token value 
    uint32 token = 1;

    // AclMatch op 
    AclMatchOperation match_op = 2;
}

/*  
 * CFM Level match condition
 */

message AclMatchCfmLevel {

    //  cfm_level value 
    uint32 cfm_level = 1;

    // AclMatch op 
    AclMatchOperation match_op = 2;
}

/*  
 * CFM opcode match condition
 */

message AclMatchCfmOpcode {

    // Minimum cfm opcode value 
    uint32 min = 1;

    // Maximum cfm opcode Value 
    uint32 max = 2;

    // AclMatch op 
    AclMatchOperation match_op = 3;
}

/* 
 * Fragment Flags
 */

enum AclFragmentFlags {

    // None 
    ACL_FRAGMENT_NONE = 0;

    // Dont fragment flag  
    ACL_DONT_FRAGMENT = 1;

    // Is fragment flag
    ACL_IS_FRAGMENT = 2;

    // First fragment flag 
    ACL_FIRST_FRAGMENT = 3;

    // More last fragment flag 
    ACL_LAST_FRAGMENT = 4;
}

/* 
 * Precedence 
 */
 
enum Precedence {

    // Routine precedence 
    ACL_PRECENCE_ROUTINE = 0;

    // Priority precedence 
    ACL_PRECENCE_PRIORITY = 1;

    // Immediate precedence 
    ACL_PRECENCE_IMMEDIATE = 2;

    // Flash precedence 
    ACL_PRECENCE_FLASH = 3;

    // Flash override precedence 
    ACL_PRECENCE_FLASH_OVERRIDE = 4;

    // Critical ecp precedence 
    ACL_PRECENCE_CRITICAL_ECP = 5;

    // Internet control precedence 
    ACL_PRECENCE_INTERNET_CONTROL = 6;

    // Network control precedence 
    ACL_PRECENCE_NET_CONTROL = 7;
}

/* 
 * TTL (Time to live) match condition for IPv4
 */
 
message AclMatchTtl {

    // Minimum Time to live 
    uint32 min = 1;

    // Maximum Time to live 
    uint32 max = 2;

    // AclMatch op 
    AclMatchOperation match_op = 3;
}

message AclMatchFragmentOffset {

    // Fragment offset range start 
    uint32 min = 1;

    // Fragment offset range start 
    uint32 max = 2;
 
    // AclMatch op 
    AclMatchOperation match_op = 3;
}

/* 
 * Police the matching packets
 */
 
message AclActionPolicer {

    // The policer 
    AccessListPolicer policer = 1;
}

/* 
 * Counter action
 */
 
message AclActionCounter {

    // Counter name (upto 64 characters) 
    string counter_name = 1;

}


/* 
 * Send To Client action
 */

message AclActionSendToClient {

    // Client name (upto 64 characters) 
    string client_name = 1;

}

/* 
 * Copy To Client action
 */

message AclActionCopyToHost {

    // Client name (upto 64 characters) 
    string client_name = 1;

}

/* 
 * Direct matching packets to a routing-instance
 */

message AclActionRoutingInstance {

    string rt_instance_name = 1;

}

/* 
 * Police the matching packets with respect to template
 */

message AclActionPolicerInstance {

    // The policer 
    AccessListPolicer policer = 1;

    // Policer Instance name
    string policer_instance = 2;
}

/*
 * Redirect matching packets with respect to topology mentioned
 */
message AclActionTopologyRedirect {

    string rt_instance_name = 1;

    string topology_name = 2;
}

/*
 * Nexthop action
 */
message AclActionSetNexthop {

    // Set nh idx 
    uint32 nh_idx = 1;

}

/*
 * action losspriority
 */
message AclActionLossPriority {

    // Set loss priority 
    AclLossPriority lp = 1;

}

/*
 * action forwording priority
 */
message AclActionForwardingPriority {

    // priority 
    uint32 priority = 1;

}

/*
 * Action forwarding class by id  
 */
message AclActionForwardingClass {

    // set forwarding class id
    AclForwardingClass fc = 1;

}

/*
 * action set dscp
 */
message AclActionSetIpDscp {

    // DSCP for IP and IPv6
    uint32 dscp = 1;

}

/*
 * Ifl Index or name in filter action
 */
message AclActionIflNameIndex {

    // Ifl index or name
    oneof AclEntryActionIflNameFormat {

        // Ifl Name
        string ifl_name = 1;

        // Ifl Index
        uint32 ifl_index = 2;
    }
}

/*
 * action next interface
 */
message AclActionNextInterface {

    // routing-instance name  
    string rti_name = 1;

    // ifl index or ifl name
    AclActionIflNameIndex ifl = 2;

}

/*
 * action next interface
 */
message AclActionNextIp {

    // routing-instance name  
    string rti_name = 1;

    // address
    jnxBase.IpAddress addr = 2; 

    // Destination prefix length 
    uint32 prefix_len = 3;

}

/* 
 * ACL Entry operation
 */

enum AclEntryOperation {

    // Invalid ACE operation
    ACL_ENTRY_OPERATION_INVALID = 0;

    // Add a new ACE. 
    // Can be used with Add ACL, Change ACL, replace ACL API's  
    ACL_ENTRY_OPERATION_ADD = 1;

    // Delete a existing ace. 
    // Can be used with change ACL API 
    ACL_ENTRY_OPERATION_DELETE = 2;

    // Replace a existing ace. Must provide adjacency details to 
    // preserve the order of the ace. Can be used with Change ACL API  
    ACL_ENTRY_OPERATION_REPLACE = 3;
}

/* 
 * Adjacency Type which determines the ACE order in an ACL
 */
 
enum AclAdjacencyType {

    // For first ace 
    ACL_ADJACENCY_NONE = 0;

    // Add next to the given ace  
    ACL_ADJACENCY_AFTER = 1;

    // Add before the given ace 
    ACL_ADJACENCY_BEFORE = 2;
}

/* 
 * Adjacency details of ace placement
 */
 
message AclAdjacency {

    // Type of adjacency placement 
    AclAdjacencyType type = 1;

    // The previous or the next AC 
    string ace_name = 2;
}

/*
 * Ifl Index or name
 */
message AclMatchIflNameIndex {

    // Ifl index or name
    oneof AclEntryMatchIflNameFormat {

        // Ifl Name
        string ifl_name = 1;

        // Ifl Index
        uint32 ifl_index = 2;
    }
}

/*
 * Flex Offset range matches
 */

message AclMatchFlexOffset {

    // Minimum range value
    uint32 min = 1;

    // Maximum range value
    uint32 max = 2;

    // AclMatch op
    AclMatchOperation match_op = 3;
}


enum AclEntryMatchFlexStartOffest {

    // Invalid Flex match start offset
    ACL_FLEX_MATCH_OFFSET_INVALID = 0;

    // Layer-3 Flex match start offset
    ACL_FLEX_MATCH_OFFSET_LAYER_THREE = 1;

    // Layer-4 Flex match start offset
    ACL_FLEX_MATCH_OFFSET_LAYER_FOUR = 2;

    // Payload Flex match start offset
    ACL_FLEX_MATCH_OFFSET_PAYLOAD = 3;

}


message AclMatchFlexibleRange {

    // Flex match start offset
    AclEntryMatchFlexStartOffest start_offset = 1;

    // Flex match bit length (0 - 32)
    uint32 bit_length = 2;

    // Flex match bit offset (0 - 7)
    uint32 bit_offset = 3;

    // Flex match byte offset
    uint32 byte_offset = 4;

    // Flex match range value
    AclMatchFlexOffset range = 5;
}
  
message AclMatchFlexibleOffsetRange {

    oneof Oneof_AclEntryMatchFlexibleOffsetRange {

        AclMatchFlexibleRange flex_range_match = 2;
    }
}


message AclMatchFlexibleMask {

    // Flex match start offset
    AclEntryMatchFlexStartOffest start_offset = 1;

    // Flex match bit length (0 - 32)
    uint32 bit_length = 2;

    // Flex match bit offset (0 - 7)
    uint32 bit_offset = 3;

    // Flex match byte offset
    uint32 byte_offset = 4;

    // Flex match mask 
    uint32 mask = 5;

    // 32 Bit, Flex match value in hex format (0x12345678)
    string prefix_string = 6;
}

message AclMatchFlexibleOffsetMask {
   
    oneof Oneof_AclEntryMatchFlexibleOffsetMask {

        AclMatchFlexibleMask flex_mask_match = 2;
    }
}

/*
 * Mac Address match condition
 */

message AclMatchMacAddress {

    // Mac address
    jnxBase.MacAddress addr = 1;

    // Mac address length
    uint32 addr_len = 2;

    // AclMatch op
    AclMatchOperation match_op = 3;
}

message AclMatchEtherType {

    // Minimum Ether type
    uint32 min = 1;

    // Maximum Ether type
    uint32 max = 2;

    // AclMatch op
    AclMatchOperation match_op = 3;
}

message AclMatchLearnVlanId {

    // Minimum Learn vlan id
    uint32 min = 1;

    // Maximum Learn vLan id
    uint32 max = 2;

    // AclMatch op
    AclMatchOperation match_op = 3;
}

message AclMatchLearnVlanPriority {

    // Minimum Learn vlan priority
    uint32 min = 1;

    // Maximum Learn vLan priority
    uint32 max = 2;

    // AclMatch op
    AclMatchOperation match_op = 3;
}

/*
 * Next hop 
 */

message AclActionNextHop {

    uint32 nh_idx = 1;
}

/* 
 * An ACL Match 
 */

message AclEntryMatchInet {
    // List of Destination addresses 
    repeated AclMatchIpAddress match_dst_addrs = 1;
    
    // List of Source addresses 
    repeated AclMatchIpAddress match_src_addrs = 2;
    
    // List of Destination ports 
    repeated AclMatchPort match_dst_ports = 3;

    // List of Source ports 
    repeated AclMatchPort match_src_ports = 4;

    // List of Dscp code points 
    repeated AclMatchDscpCode match_dscp_code = 5;

    // List of Protocols 
    repeated AclMatchProtocol match_protocols = 6;

    // List of Icmp types 
    repeated AclMatchIcmpType match_icmp_type = 7;

    // List of Icmp codes 
    repeated AclMatchIcmpCode match_icmp_code = 8;

    // List of Packet lengths 
    repeated AclMatchPktLen match_pkt_len = 9;

    // List of Ttl's 
    repeated AclMatchTtl match_ttl = 10;

    // Fragment flag 
    AclFragmentFlags fragment_flags = 11;

    // List of fragment offset range 
    repeated AclMatchFragmentOffset match_frag_offset = 12;

    // Interface name (IFL with unit e.g. ge-0/0/1.0 or IFL index) 
    repeated AclMatchIflNameIndex ifl_names = 13;

    // List of ip precedence
    repeated AclMatchIpPrecedence match_ip_precedence = 14; 

    // List of Addresses
    repeated AclMatchIpAddress match_addrs = 15;

    // List of Ports
    repeated AclMatchPort match_ports = 16;

    // Flex Ranges
    AclMatchFlexibleOffsetRange match_flex_range = 17;

    // Flex Masks
    AclMatchFlexibleOffsetMask match_flex_mask = 18; 
}
/* 
 * Terminating ACL Action
 */

message AclEntryInetTerminatingAction {
    oneof Oneof_AclEntryInetTerminatingAction {

        // Accept the matching packets
        AclBooleanType action_accept = 1;
    
        // Discard the matching packets
        AclBooleanType action_discard = 2;
    
        // Reject the matching packets
        AclEntryActionRejectReason action_reject = 3;
    
        // Direct matching packets to a routing instance
        AclActionRoutingInstance action_rt_inst = 4;
    }
}

/* 
 * Non-terminating ACL Action
 */

message AclEntryInetNonTerminatingAction {

        // Count the matching packets
        AclActionCounter action_count = 1;
    
        // Log the matching packets
        AclBooleanType action_log = 2;
    
        // Syslog the matching packets
        AclBooleanType action_syslog = 3;
    
        // Police the matching packets.
        // Ensure that policer exists before it being used.
        AclActionPolicer action_policer = 4;
    
        // Sample
        AclBooleanType action_sample = 5;
    
        // Next Term
        AclBooleanType action_next_term = 6;
}

/* 
 * ACL Action
 */

message AclEntryInetAction {

    // List of non-terminating actions.
    AclEntryInetNonTerminatingAction actions_nt = 1;

    // One terminating action
    AclEntryInetTerminatingAction action_t = 2;
}

/* 
 * An Inet ACL entry
 */

message AclInetEntry {

    // AclEntry name
    string ace_name = 1;

    // AclEntry operation 
    AclEntryOperation ace_op = 2;

    // Adjacency 
    AclAdjacency adjacency = 3;

    // Matches 
    AclEntryMatchInet matches = 4;

    // Actions 
    AclEntryInetAction actions = 5;
}

/* 
 * An ACL Match 
 */

message AclEntryMatchEs {

    // List of Destination mac addresses 
    repeated AclMatchMacAddress match_dst_mac_addrs = 1;
    
    // List of Source mac addresses 
    repeated AclMatchMacAddress match_src_mac_addrs = 2;
    
    // List of Destination ports 
    repeated AclMatchPort match_dst_ports = 3;

    // List of Source ports 
    repeated AclMatchPort match_src_ports = 4;

    // List of Dscp code points 
    repeated AclMatchDscpCode match_dscp_code = 5;

    // List of Protocols 
    repeated AclMatchProtocol match_protocols = 6;
    
    // List of Icmp types 
    repeated AclMatchIcmpType match_icmp_type = 7;

    // List of Icmp codes 
    repeated AclMatchIcmpCode match_icmp_code = 8;

    // Interface name (IFL with unit e.g. ge-0/0/1.0 or IFL index) 
    repeated AclMatchIflNameIndex ifl_names = 9;

    //List of Ether type
    repeated AclMatchEtherType match_ether_type = 10;

    //List of Learn vlan id
    repeated AclMatchLearnVlanId match_learn_vlan_id = 11;

    //List of learn vlan priority 
    repeated AclMatchLearnVlanPriority match_learn_vlan_priority = 12;
}

/* 
 * Terminating ACL Action
 */

message AclEntryEsTerminatingAction {
    oneof Oneof_AclEntryEsTerminatingAction {

        // Accept the matching packets
        AclBooleanType action_accept = 1;
    
        // Discard the matching packets
        AclBooleanType action_discard = 2;

        // Next hop
        AclActionNextHop action_nh = 3;

        // Send to host
        AclBooleanType action_send_to_host = 4;
    }
}

/* 
 * Non-terminating ACL Action
 */

message AclEntryEsNonTerminatingAction {

        // Count the matching packets
        AclActionCounter action_count = 1;
    
        // Log the matching packets
        AclBooleanType action_log = 2;
    
        // Syslog the matching packets
        AclBooleanType action_syslog = 3;
    
        // Police the matching packets.
        // Ensure that policer exists before it being used.
        AclActionPolicer action_policer = 4;
    
        // Next Term
        AclBooleanType action_next_term = 5;

        // Loss priority
        AclActionLossPriority action_lp = 6;
}

/* 
 * ACL Action
 */

message AclEntryEsAction {

    // List of non-terminating actions.
    AclEntryEsNonTerminatingAction actions_nt = 1;

    // One terminating action
    AclEntryEsTerminatingAction action_t = 2;
}

/* 
 * An Inet ACL entry
 */

message AclEsEntry {

    // AclEntry name
    string ace_name = 1;

    // AclEntry operation 
    AclEntryOperation ace_op = 2;

    // Adjacency 
    AclAdjacency adjacency = 3;

    // Matches 
    AclEntryMatchEs matches = 4;

    // Actions 
    AclEntryEsAction actions = 5;
}

/*
 * Inet6 Matches and actions 
 */

message AclEntryMatchInet6 {
    // List of Destination addresses 
    repeated AclMatchIpAddress match_dst_addrs = 1;

    // List of Source addresses 
    repeated AclMatchIpAddress match_src_addrs = 2;

    // List of Destination ports 
    repeated AclMatchPort match_dst_ports = 3;

    // List of Source ports 
    repeated AclMatchPort match_src_ports = 4;

    // List of Dscp code points 
    repeated AclMatchDscpCode match_dscp_code = 5;

    // List of Protocols 
    repeated AclMatchProtocol payload_protocols = 6;

    // List of Icmp types 
    repeated AclMatchIcmpType match_icmp_type = 7;

    // List of Icmp codes 
    repeated AclMatchIcmpCode match_icmp_code = 8;

    // List of Packet lengths 
    repeated AclMatchPktLen match_pkt_len = 9;

    // Fragment flag 
    AclFragmentFlags fragment_flags = 10;

    // Interface name (IFL with unit e.g. ge-0/0/1.0 or IFL index) 
    repeated AclMatchIflNameIndex ifl_names = 11;

    // List of traffic classes
    repeated AclMatchTrafficClass match_traffic_classes = 12;

    // List of Addresses
    repeated AclMatchIpAddress match_addrs = 13;

    // Flex Ranges
    AclMatchFlexibleOffsetRange match_flex_range = 14;

    // Flex Masks
    AclMatchFlexibleOffsetMask match_flex_mask = 15;

    // List of Next Header match 
    repeated AclMatchNextHeader ipv6_next_headers = 16; 

    // List of Loss Priority 
    repeated AclMatchLossPriority match_loss_priority = 17; 

    // List of Forwarding Class  
    repeated AclMatchForwardingClass match_fwd_class = 18;      

    // List of Ports
    repeated AclMatchPort match_ports = 19;
}

/* 
 * Terminating ACL inet6 Actions
 */

message AclEntryInet6TerminatingAction {
    oneof Oneof_AclEntryInet6TerminatingAction {

        // Accept the matching packets
        AclBooleanType action_accept = 1;

        // Discard the matching packets
        AclBooleanType action_discard = 2;

        // Reject the matching packets
        AclEntryActionRejectReason action_reject = 3;

        // Direct matching packets to a routing instance
        AclActionRoutingInstance action_rt_inst = 4;

        // Direct matching packets to a routing instance
        AclActionTopologyRedirect action_topo_redirect = 5;     

        // client name
        AclActionSendToClient action_send_to_client = 6;

        // Direct matching packets to host
        AclBooleanType action_send_to_host = 7;     

        // set nexthop idx
        AclActionSetNexthop action_nh = 8; 
    }
}

/* 
 * Non-terminating ACL inet6 Actions
 */

message AclEntryInet6NonTerminatingAction {

    // Count the matching packets
    AclActionCounter action_count = 1;

    // Log the matching packets
    AclBooleanType action_log = 2;

    // Syslog the matching packets
    AclBooleanType action_syslog = 3;

    // Police the matching packets.
    // Ensure that policer exists before it being used.
    AclActionPolicer action_policer = 4;

    // Sample
    AclBooleanType action_sample = 5;

    // Next Term
    AclBooleanType action_next_term = 6;

    // port mirror action 
    AclBooleanType action_port_mirror = 7; 

    // set loss priority to matched packets
    AclActionLossPriority action_lp = 8;

    // set Forwarding class to matched packets
    AclActionForwardingClass action_fwd_class = 9;

    // set Forwarding Priority to matched packets
    AclActionForwardingPriority action_fwd_priority = 10;

    // set Next interface to matched packets
    AclActionNextInterface action_next_intf = 11;

    // set Next IPv4 to matched packets
    AclActionNextIp action_next_ip = 12;

    // set IP DSCP to matched packets
    AclActionSetIpDscp action_ip_dscp = 13;     

    // Copy of matching packets to host     
    // client name
    AclActionCopyToHost action_copy_to_host = 14;

    // Police the matching packets.
    // Ensure that policer exists before it being used.
    AclActionPolicerInstance action_policer_inst = 15;
}

/* 
 * ACL inet6 Actions
 */

message AclEntryInet6Action {

    // List of non-terminating actions.
    AclEntryInet6NonTerminatingAction actions_nt = 1;

    // One terminating action
    AclEntryInet6TerminatingAction action_t = 2;
}

/* 
 * Inet6 Matches and actions END
 */

/*
 *  VPLS Matches and Actions
 */

message AclEntryMatchVpls {
    // List of Destination addresses (V4) 
    repeated AclMatchIpAddress match_dst_addrs = 1;

    // List of Source addresses (V4)
    repeated AclMatchIpAddress match_src_addrs = 2;

    // List of Destination addresses (V6) 
    repeated AclMatchIpAddress match_dst_v6_addrs = 3;

    // List of Source addresses (V6)
    repeated AclMatchIpAddress match_src_v6_addrs = 4;

    // List of Destination ports 
    repeated AclMatchPort match_dst_ports = 5;

    // List of Source ports 
    repeated AclMatchPort match_src_ports = 6;

    // List of Dscp code points 
    repeated AclMatchDscpCode match_dscp_code = 7;

    // List of Protocols 
    repeated AclMatchProtocol match_ip_protocols = 8;

    // List of Protocols 
    repeated AclMatchProtocol payload_protocols = 9;

    // List of Icmp types 
    repeated AclMatchIcmpType match_icmp_type = 10;

    // List of Icmp codes 
    repeated AclMatchIcmpCode match_icmp_code = 11;

    // Interface name (IFL with unit e.g. ge-0/0/1.0 or IFL index) 
    repeated AclMatchIflNameIndex ifl_names = 12;

    // List of traffic classes
    repeated AclMatchTrafficClass match_traffic_classes = 13;

    // List of Next Header match 
    repeated AclMatchNextHeader ipv6_next_headers = 14;

    // List of Ether type match 
    repeated AclMatchEtherType ether_types = 15;    

    // List Source MAC match 
    repeated AclMatchMacAddress match_src_macs = 16;    

    // List Destination MAC match 
    repeated AclMatchMacAddress match_dst_macs = 17;

    // List of Ether type match 
    repeated AclMatchEtherType vlan_ether_types = 18;       

    // List of Vlan Id match 
    repeated AclMatchVlanId learn_vlan_ids = 19;        

    // List of Vlan Id match 
    repeated AclMatchVlanId user_vlan_ids = 20;

    // List of Vlan Id match 
    repeated AclMatchLearnVlanPriority learn_vlan_priority = 21;    

    // STP state match 
    AclStpMatchFlags stp_state = 22;       

    // List of mesh group id match 
    repeated AclMatchMeshGroup mesh_group_ids = 23; 

    // List of CFM Opcode match 
    repeated AclMatchCfmOpcode cfm_opcodes = 24;    

    // List of CFM Level match 
    repeated AclMatchCfmLevel cfm_levels = 25;

    // List of L2 token match 
    repeated AclMatchL2Token l2_tokens = 26;    

    // List of Ipv6 addresses (V6)
    repeated AclMatchIpAddress match_v6_addrs = 27;

    // Flex Ranges
    AclMatchFlexibleOffsetRange match_flex_range = 28;

    // Flex Masks
    AclMatchFlexibleOffsetMask match_flex_mask = 29;

    // List of Packet lengths 
    repeated AclMatchPktLen match_pkt_len = 30;
}

/* 
 * Terminating ACL Vpls Actions
 */

message AclEntryVplsTerminatingAction {
    oneof Oneof_AclEntryVplsTerminatingAction {

        // Accept the matching packets
        AclBooleanType action_accept = 1;

        // Discard the matching packets
        AclBooleanType action_discard = 2;

        // Direct matching packets to client
        // client name
        AclActionSendToClient action_send_to_client = 3;

        // Direct matching packets to host
        AclBooleanType action_send_to_host = 4;

        // set nexthop idx
        AclActionSetNexthop action_nh = 5;
    }
}

/* 
 * Non-terminating ACL Vpls Actions
 */

message AclEntryVplsNonTerminatingAction {

    // Count the matching packets
    AclActionCounter action_count = 1;

    // Log the matching packets
    AclBooleanType action_log = 2;

    // Syslog the matching packets
    AclBooleanType action_syslog = 3;

    // Police the matching packets.
    // Ensure that policer exists before it being used.
    AclActionPolicer action_policer = 4;

    // Sample
    AclBooleanType action_sample = 5;

    // Next Term
    AclBooleanType action_next_term = 6;

    // No Mac Learn
    AclBooleanType action_no_mac_learn = 7;

    // Copy of matching packets to host 
    // client name      
    AclActionCopyToHost action_copy_to_host = 8;
}

/* 
 * ACL VPLS Action
 */

message AclEntryVplsAction {

    // List of non-terminating actions.
    AclEntryVplsNonTerminatingAction actions_nt = 1;

    // One terminating action
    AclEntryVplsTerminatingAction action_t = 2;
}

/* 
 * VPLS Matches and actions END
 */

/*
 *  CCC Matches and Actions
 */

message AclEntryMatchCcc {

    // List of Packet lengths 
    repeated AclMatchPktLen match_pkt_len = 1;

    // Interface name (IFL with unit e.g. ge-0/0/1.0 or IFL index) 
    repeated AclMatchIflNameIndex ifl_names = 2;

    // List of Ether type match 
    repeated AclMatchEtherType ether_types = 3;    

    // List Source MAC match 
    repeated AclMatchMacAddress match_src_macs = 4;    

    // List Destination MAC match 
    repeated AclMatchMacAddress match_dst_macs = 5;

    // List of CFM Opcode match 
    repeated AclMatchCfmOpcode cfm_opcodes = 6;    

    // List of CFM Level match 
    repeated AclMatchCfmLevel cfm_levels = 7;

    // Flex Ranges
    AclMatchFlexibleOffsetRange match_flex_range = 8;

    // Flex Masks
    AclMatchFlexibleOffsetMask match_flex_mask = 9;
}

/* 
 * Terminating ACL CCC Actions
 */

message AclEntryCccTerminatingAction {
    oneof Oneof_AclEntryCccTerminatingAction {

        // Accept the matching packets
        AclBooleanType action_accept = 1;

        // Discard the matching packets
        AclBooleanType action_discard = 2;

        // Direct matching packets to client
        // client name
        AclActionSendToClient action_send_to_client = 3;

        // Direct matching packets to host
        AclBooleanType action_send_to_host = 4;
    }
}

/* 
 * Non-terminating ACL CCC Actions
 */

message AclEntryCccNonTerminatingAction {

    // Count the matching packets
    AclActionCounter action_count = 1;

    // Log the matching packets
    AclBooleanType action_log = 2;

    // Syslog the matching packets
    AclBooleanType action_syslog = 3;

    // Police the matching packets.
    // Ensure that policer exists before it being used.
    AclActionPolicer action_policer = 4;

    // Sample
    AclBooleanType action_sample = 5;

    // Copy of matching packets to host
    // client name      
    AclActionCopyToHost action_copy_to_host = 6;
}

/* 
 * ACL CCC Action
 */

message AclEntryCccAction {

    // List of non-terminating actions.
    AclEntryCccNonTerminatingAction actions_nt = 1;

    // One terminating action
    AclEntryCccTerminatingAction action_t = 2;
}

/* 
 * CCC Matches and actions END
 */ 

/*
 *  multiservices Matches and Actions
 */

message AclEntryMatchMultiService {
    // List of Destination addresses (V4) 
    repeated AclMatchIpAddress match_dst_addrs = 1;

    // List of Source addresses (V4)
    repeated AclMatchIpAddress match_src_addrs = 2;

    // List of addresses (V4)
    repeated AclMatchIpAddress match_addrs = 3; 

    // List of Destination ports 
    repeated AclMatchPort match_dst_ports = 4;

    // List of Source ports 
    repeated AclMatchPort match_src_ports = 5;

    // List of Protocols 
    repeated AclMatchProtocol match_ip_protocols = 6;

    // List of Protocols 
    repeated AclMatchProtocol payload_protocols = 7;    

    // List of Icmp types 
    repeated AclMatchIcmpType match_icmp_type = 8;

    // List of Icmp codes 
    repeated AclMatchIcmpCode match_icmp_code = 9;

    // Interface name (IFL with unit e.g. ge-0/0/1.0 or IFL index) 
    repeated AclMatchIflNameIndex ifl_names = 10; 

    // List of Next Header match 
    repeated AclMatchNextHeader ipv6_next_headers = 11; 

    // List of Ether type match 
    repeated AclMatchEtherType ether_types = 12;    

    // List Source MAC match 
    repeated AclMatchMacAddress match_src_macs = 13;    

    // List Destination MAC match 
    repeated AclMatchMacAddress match_dst_macs = 14;

    // List of Ether type match 
    repeated AclMatchEtherType vlan_ether_types = 15;   

    // STP state match 
    AclStpMatchFlags stp_state = 16;       

    // List of mesh group id match 
    repeated AclMatchMeshGroup mesh_group_ids = 17; 

    // List of L2 token match 
    repeated AclMatchL2Token l2_tokens = 18;

    // List of Packet lengths 
    repeated AclMatchPktLen match_pkt_len = 19;
}

/* 
 * Terminating ACL Multi Service Actions
 */

message AclEntryMultiServiceTerminatingAction {
    oneof Oneof_AclEntryMultiServiceTerminatingAction {

        // Accept the matching packets
        AclBooleanType action_accept = 1;

        // Discard the matching packets
        AclBooleanType action_discard = 2;

        // Direct matching packets to client
        // client name
        AclActionSendToClient action_send_to_client = 3;

        // Direct matching packets to host
        AclBooleanType action_send_to_host = 4;
    }
}

/* 
 * Non-terminating ACL Multi Service Actions
 */

message AclEntryMultiServiceNonTerminatingAction {

    // Count the matching packets
    AclActionCounter action_count = 1;

    // Log the matching packets
    AclBooleanType action_log = 2;

    // Syslog the matching packets
    AclBooleanType action_syslog = 3;

    // Police the matching packets.
    // Ensure that policer exists before it being used.
    AclActionPolicer action_policer = 4;

    // Sample
    AclBooleanType action_sample = 5;

    // Next Term
    AclBooleanType action_next_term = 6;

    // Copy of matching packets to host
    AclActionCopyToHost action_copy_to_host = 7;        
}

/* 
 * ACL Multi Service Actions
 */

message AclEntryMultiServiceAction {

    // List of non-terminating actions.
    AclEntryMultiServiceNonTerminatingAction actions_nt = 1;

    // One terminating action
    AclEntryMultiServiceTerminatingAction action_t = 2;
}

/* 
 * multiservices Matches and actions END
 */ 

/*
 *  Mpls Matches and Actions
 */

message AclEntryMatchMpls {
    // Label-1 match
    repeated AclMatchMplsLabel match_label1 = 1;

    // Label-2 match
    repeated AclMatchMplsLabel match_label2 = 2;

    // Label-3 match
    repeated AclMatchMplsLabel match_label3 = 3;

    // Flex Ranges
    AclMatchFlexibleOffsetRange match_flex_range = 4;

    // Flex Masks
    AclMatchFlexibleOffsetMask match_flex_mask = 5;
}

/* 
 * Terminating ACL MPLS Actions
 */

message AclEntryMplsTerminatingAction {
    oneof Oneof_AclEntryMplsTerminatingAction {

        // Accept the matching packets
        AclBooleanType action_accept = 1;

        // Discard the matching packets
        AclBooleanType action_discard = 2;
    }
}

/* 
 * Non-terminating ACL MPLS Actions
 */

message AclEntryMplsNonTerminatingAction {

    // Count the matching packets
    AclActionCounter action_count = 1;

    // Police the matching packets.
    // Ensure that policer exists before it being used.
    AclActionPolicer action_policer = 2;
}

/* 
 * ACL Mpls Action
 */

message AclEntryMplsAction {

    // List of non-terminating actions.
    AclEntryMplsNonTerminatingAction actions_nt = 1;

    // One terminating action
    AclEntryMplsTerminatingAction action_t = 2;
}

/* 
 * Mpls Matches and actions END
 */ 



/* 
 * An Inet6 ACL entry
 */

message AclInet6Entry {

    // AclEntry name
    string ace_name = 1;

    // AclEntry operation 
    AclEntryOperation ace_op = 2;

    // Adjacency 
    AclAdjacency adjacency = 3;

    // Matches 
    AclEntryMatchInet6 matches = 4;

    // Actions 
    AclEntryInet6Action actions = 5;
}

/* 
 * VPLS ACL entry
 */

message AclVplsEntry {

    // AclEntry name
    string ace_name = 1;

    // AclEntry operation 
    AclEntryOperation ace_op = 2;

    // Adjacency 
    AclAdjacency adjacency = 3;

    // Matches 
    AclEntryMatchVpls matches = 4;

    // Actions 
    AclEntryVplsAction actions = 5;
}

/* 
 * CCC ACL entry
 */

message AclCccEntry {

    // AclEntry name
    string ace_name = 1;

    // AclEntry operation 
    AclEntryOperation ace_op = 2;

    // Adjacency 
    AclAdjacency adjacency = 3;

    // Matches 
    AclEntryMatchCcc matches = 4;

    // Actions 
    AclEntryCccAction actions = 5;
}

/* 
 * MultiServices ACL entry
 */

message AclMultiServiceEntry {

    // AclEntry name
    string ace_name = 1;

    // AclEntry operation 
    AclEntryOperation ace_op = 2;

    // Adjacency 
    AclAdjacency adjacency = 3;

    // Matches 
    AclEntryMatchMultiService matches = 4;

    // Actions 
    AclEntryMultiServiceAction actions = 5;
}


/* 
 * MPLS ACL entry
 */

message AclMplsEntry {

    // AclEntry name
    string ace_name = 1;

    // AclEntry operation 
    AclEntryOperation ace_op = 2;

    // Adjacency 
    AclAdjacency adjacency = 3;

    // Matches 
    AclEntryMatchMpls matches = 4;

    // Actions 
    AclEntryMplsAction actions = 5;
}

/* 
 * An ACL entry. It could be one of type of families.
 */
 
message AclEntry {
    oneof OneOf_AclEntry {

        // For Inet family
        AclInetEntry inet_entry = 1;

        // For Ethernet Switching family
        AclEsEntry es_entry = 2;

        // For Inet6 family
        AclInet6Entry inet6_entry = 3;

        // For vpls family
        AclVplsEntry vpls_entry = 4;

        // For ccc family
        AclCccEntry ccc_entry = 5;

        // For multiservices family
        AclMultiServiceEntry mservice_entry = 6;

        // For mpls family
        AclMplsEntry mpls_entry = 7;

    }
}


/* 
 * AccessList types. 
 */
 
enum AccessListTypes {

    // Invalid ACL type
    ACL_TYPE_INVALID = 0;

    // Classic ACL type  
    ACL_TYPE_CLASSIC = 1;
}

/* 
 * AccessList Families. 
 */
 
enum AccessListFamilies {

    // Invalid
    ACL_FAMILY_INVALID = 0;

    // IPv4 family  
    ACL_FAMILY_INET = 1;

    // IPv6 family
    ACL_FAMILY_INET6 = 2;

    // Ethernet Switching family
    ACL_FAMILY_ES = 3;

    // VPLS family
    ACL_FAMILY_VPLS = 4;

    // MULTISERVICE family
    ACL_FAMILY_MULTISERVICE = 5;

    // CCC family
    ACL_FAMILY_CCC = 6;

    // MPLS family
    ACL_FAMILY_MPLS = 7;
}

/* 
 * Any proprietory flag to be enabled at the ACL level.
 */
 
enum AccessListFlags {

    // None 
    ACL_FLAGS_NONE = 0;
}

/* 
 * ACL
 */
 
message AccessList {

    // AccessList name
    string acl_name = 1;

    // AccessList type 
    AccessListTypes acl_type = 2;

    // AccessList family 
    AccessListFamilies acl_family = 3;

    // AccessList flag 
    AccessListFlags acl_flag = 4;

    // List of Destination addresses 
    repeated AclEntry ace_list = 5;
}

/* 
 * Direction in which an ACL is bound.
 */
 
enum AclBindDirection {

    ACL_BIND_DIRECTION_INVALID = 0;

    // Bind on ingress  
    ACL_BIND_DIRECTION_INPUT = 1;

    // Bind on egress  
    ACL_BIND_DIRECTION_OUTPUT = 2;
}

message AccessListCounter {

     AccessList acl = 1;

     string counter_name = 2;
}

message AccessListCounterBulk {

     AccessList acl = 1;

     uint32 starting_index = 2;
}

/*
 * Return values for the RPCs.
 */

enum AccessListReturnVal {
    
    // Success
    ACL_STATUS_EOK = 0;

    // The RPC was a NULL buffer
    ACL_STATUS_NULL_MESSAGE = 1;

    // Wrong input
    ACL_STATUS_EINVALID_MESSAGE = 2;

    // Server Internal error 
    ACL_STATUS_EINTERNAL = 3;

    // Operation not supported
    ACL_STATUS_EUNSUPPORTED_OP = 4;

    // Resource not available at server
    ACL_STATUS_NO_RESOURCE = 5;
 
    // Bulk Stats timeout
    ACL_STATUS_BS_TIMEOUT = 6;
}

message AccessListReturnStatus {

     AccessListReturnVal status = 1;
}

/* 
 * Return counter statistics
 */
 
message AccessListCounterVal {

    // Counter Name 
    string counter_name = 1;

    // Error status 
    AccessListReturnVal status = 2;

    // Byte count 
    uint64 bytes = 3;

    // Packet count 
    uint64 packets = 4;

}

/* 
 * The forwarding element entities to which the ACL can be bound.
 */

enum AccessListBindObjType {

    // Invalid
    ACL_BIND_OBJ_TYPE_INVALID = 0;

    // Interface 
    ACL_BIND_OBJ_TYPE_INTERFACE = 1;

    // Forwarding table 
    ACL_BIND_OBJ_TYPE_FWD_TABLE = 2;

    // Forwarding table 
    ACL_BIND_OBJ_TYPE_VLAN = 3;	

    // Bridge domain 
    ACL_BIND_OBJ_TYPE_BRG_DOMAIN = 4;

}

message AclBindObjVlan {
    // Bind object VLAN name where the ACL is to be bound
    string vlan_name = 1;

    // Bind object Routing Instance name of vlan_name where the ACL is to be bound
    string rtb_name = 2;
}

message AclBindObjBridgeDomain {
    // Bind object bd name where the ACL is to be bound
    string bd_name = 1;

    // Bind object Routing Instance name of bd_name where the ACL is to be bound
    string rtb_name = 2;
}

message AccessListBindObjPoint {
    oneof OneOf_AclBindPoint {

        // Bind object name where the ACL is to be bound
        string intf = 1;

        // Bind object name where the ACL is to be bound
        string fwd_table = 2;

        // Bind object name where the ACL is to be bound
        AclBindObjVlan vlan = 3;

        // bind object bridge domain
        AclBindObjBridgeDomain bd = 4;

    }
}

/* 
 * Per forwarding element ACL binding
 */

message AccessListObjBind {

    // ACL
    AccessList acl = 1;
    
    // Binding object type
    AccessListBindObjType obj_type = 2;

    // Bind object name where the ACL is to be bound
    AccessListBindObjPoint bind_object = 3;

    // Bind direction 
    AclBindDirection bind_direction = 4;

    // Family on the bind object. Must match with the ACL family 
    AccessListFamilies bind_family = 5;
}

/* 
 * ACL Service APIs defines a set of simple RPCs to operate upon the various
 * components, viz. 
 *  - ACL
 *  - ACE
 *  - Policer
 *  - Attachment Points
 *  - Statistics.
 * 
 * Each of RPCs are named by concatenating the corresponding Acl object and the operation 
 * to be performed. This give a easy to understand semantics to the RPCs.
 * 
 */
  
service AclService {

        // Adds an ACL and returns the result.
	rpc AccessListAdd ( AccessList ) returns ( AccessListReturnStatus ) {}

        // Delete an ACL from the system and return the result.
        // For successful delete to happen, the ACL should not be bound to any object.
	rpc AccessListDelete ( AccessList ) returns ( AccessListReturnStatus ) {}

        // Changes an ACL based on the list of ACL entries provided, and returns the result.
        // It is advisable to use this API to for small incremental changes. For wholesale 
        // changes, it is recommended to use the 'Replace' version of the API.
	rpc AccessListChange ( AccessList ) returns ( AccessListReturnStatus ) {}

        // Add a binding of an ACL with a bind object and return the result.
	rpc AccessListBindAdd ( AccessListObjBind ) returns ( AccessListReturnStatus ) {}

        // Deletes a binding of an ACL with a bind object and return the result.
        rpc AccessListBindDelete ( AccessListObjBind ) returns ( AccessListReturnStatus ) {}

        // Adds a policer and returns the result.
	rpc AccessListPolicerAdd ( AccessListPolicer ) returns ( AccessListReturnStatus ) {}

        // Changes a policer and returns the result.
	rpc AccessListPolicerReplace( AccessListPolicer ) returns ( AccessListReturnStatus ) {}

        // Deletes a policer and returns the result.
	rpc AccessListPolicerDelete( AccessListPolicer ) returns ( AccessListReturnStatus ) {}

        // Following are optimized command to let the server know to <br>
        // accumulate the Access List Entries and configure on when AccessListPileupEnd is received. <br>
        // For every AccessList RPC invocation, the entire ACL is applied to the system <br>
        // For application which wants to do batching for better performance, the AccessListPileupStart <br>
        // and AccessListPileupEnd will help achive that.
        
       rpc AccessListPileupStart(AccessListVoid) returns ( AccessListReturnStatus ) {}

       // Following are optimized command to let the server know to <br>
       // accumulate the ace_list and configure on when AccessListPileupEnd is received. <br>
       // For every AccessList RPC invocation, the entire ACL is applied to the system <br>
       // For application which wants to do batching for better performance, the AccessListPileupStart <br>
       // and AccessListPileupEnd will help achive that.

       rpc AccessListPileupEnd (AccessListVoid) returns ( AccessListReturnStatus ) {}
   
        // Few points to note with this API. 
        // The call is going to be blocking for worst case of 10 seconds which is non configurable.
        // The counter name is expected to be fully resolved. For eg. for term specific policer counter
        // it is expected to be passed to full counter name.

        rpc AccessListCounterGet ( AccessListCounter ) returns ( AccessListCounterVal ) {}

        rpc AccessListPolicerCounterGet ( AccessListCounter ) returns ( AccessListCounterVal ) {}

        // Clears a particular counter whose fully qualified name is provided,  associated with an ACL.
        // Few points to note with this API. Currently only 1 counter get is supported.
        // The counter name is expected to be fully resolved. For eg. for term specific policer counter
        // it is expected to be passed to full counter name.
    
	rpc AccessListCounterClear ( AccessListCounter )  returns ( AccessListReturnStatus ) {}

        // Get all the counters associated with an ACL.
        // Each call to this API will return 10 counters from the starting_index specified in AccessListCounterBulk message.
        // The client is expected to run this API in loop which should stop in either one of the following condition:
	//     a. The targeted number of counters are retrieved.
        //     b. An error is returned.
        //     c. The API returns less than 10 counters.
        
        rpc AccessListCounterBulkGet( AccessListCounterBulk ) returns ( stream AccessListCounterVal ) {}

        // Get all the policer counters associated with an ACL.
        // Each call to this API will return 10 counters from the starting_index specified in AccessListCounterBulk message.
        // The client is expected to run this API in loop which should stop in either one of the following condition:
	//     a. The targeted number of counters are retrieved.
        //     b. An error is returned.
        //     c. The API returns less than 10 counters.
        
        rpc AccessListPolicerCounterBulkGet( AccessListCounterBulk ) returns ( stream AccessListCounterVal ) {}
}
